#!/usr/bin/perl
######################################################################
#Monitoring simulation batch
#   Details:
#       1. monitoring the directory $HOME/simulation/active_batch, where keeps all active simulation batches stored as a file for each active batch. The file name is batchdir-YYYYMMDD-HHMNSS.
#
# Copyright (C) 2011, 2012 Yi-Xin Liu
# Contact: liuyxpp@gmail.com
#
#Since: 1/27/2011
#version 1.2, 5/4/2012
#version 1.1, 3/15/2011
######################################################################

use Date::Manip;
use Time::HiRes;
use POSIX qw/strftime/;

#$batchfile="batchdir-20110127-181230";
$basedir="/export/home/lyx/simulation/active_batch";
while(1){
my $curtime=strftime('%Y%m%d-%H%M%S',localtime);
print "Checking active batch ($curtime) ...\n\n";
my @batchfiles=glob("$basedir/batchdir-*");
foreach(@batchfiles){
#    print $_."\n";
    $batchfile=$_;
    $batchfile=~/(batchdir-\d+-\d+)/;
    $batchName=$1;
    $batchfile=~/(\d+-\d+)/;
    $datebatch=$1; #$1 contains the matching string,which of the form YYYYMMDD-HHMNSS. This format can be manipulate by Date:Manip directly.
    print "Active simulation units of $batchName:\n";
    $isBatchFinish=1;
#obtain all batch dirs in the batch file
    open FILE,"<$batchfile";
    my @batchdirs;
    while(<FILE>){
        chomp $_;
#verify each batch dir
        if(-e $_){
#            print $_."\n";
            push(@batchdirs,$_);
        }
    }
    close FILE;
#for each batch dir, check whether the simulation finished.
#Two criteria: (1) done.txt must exist;
#              (2) the last modified time must newer than the time in the name of batchfile, datebatch.
    foreach(@batchdirs){
#        print $_."\n";
        $donefile=$_."/done.txt";
        if(-e $donefile){
# ensure that the done.txt file is not generated by last batch which happened to have the same parameter set.
            $epoch_timestamp=(stat($donefile))[9];
            $timestamp=strftime('%Y%m%d-%H%M%S',localtime($epoch_timestamp));
            $flag=Date_Cmp($datebatch,$timestamp);
            if($flag>=0){
                $isBatchFinish=0;
                print "-->$_\n";
            }
        }
        else{
            $isBatchFinish=0;
            print "-->$_\n";
        }
    }
    if($isBatchFinish){
        $batchBasePath=$batchdirs[0]."/..";
        $param_file = "param-".$datebatch.".ini";
        system "mv $batchfile $batchBasePath";
        sleep 1;
        system "bscft -c $batchBasePath/$param_file &";
        sleep 2;
        print "$batchName has finished.\n";
        print "$batchName has been moved to $batchBasePath.\n";
        print "Data files has been processed by bscft.\n\n";
# Logging finished batches
        my $fintime=strftime("%Y%m%d-%H%M%S",localtime);
        open LOGFILE, ">>".$basedir."/batch.log";
            print LOGFILE "$fintime\t$batchBasePath/$batchName\n";
        close LOGFILE;
    }
    else{
        print "$batchName is still active!\n\n";
    }
}
print "Waiting for\033[34;49m 600\033[m seconds to check again.\n";
print "Waiting.... \033[35;49m";
$|=1; # set the 'autoflush' on STDOUT. This is required for following codes.
my $time_step = 0.2;
my $t=0;
my $type = 0;
while($t<600){
    if($type == 0) { print "\b/"; }
    if($type == 1) { print "\b-"; }
    if($type == 2) { print "\b\\"; }
    if($type == 3) { print "\b|"; }
    $type += 1;
    if($type == 4) { $type = 0; }
    Time::HiRes::sleep($time_step);
    $t += $time_step;
}
print "\033[m\nChecking....\n";
}
